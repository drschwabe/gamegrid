(function() {

  var gg = {}

  // global on the server, window in the browser
  var root = this;

  // Node.js specific:
  if (typeof module !== 'undefined' && module.exports) {
    var ROT = require('rot-js') //< Use node module.
  } else {
    var ROT = window.ROT //< Use script tag.
  }

  gg.isArrowKey = function(keyCode) {
    return _.contains([38, 39, 40, 37], keyCode)
  }

  gg.getDirection = function(keyCode) {
    if(keyCode == 38) return 'north'
    if(keyCode == 39) return 'east'
    if(keyCode == 40) return 'south'
    if(keyCode == 37) return 'west'
  }

  gg.move = function(grid, enty, direction) {

    function nextCell(grid, enty, direction) {
      //Returns the cell # for the nearest cell in the given direction:
      var nextCell,
          gridSize = grid.height * grid.width
      switch(direction) {
        case 'north':
          if( enty.cell < grid.width ) { //< Check for map edge...
            nextCell = 'map edge'
            break
          }
          nextCell = enty.cell - grid.height
          break
        case 'east':
          if( enty.cell % grid.width == grid.width - 1) {
            nextCell = 'map edge'
            break
          }
          nextCell = enty.cell + 1
          break
        case 'south':
          if( enty.cell > gridSize - (grid.width +1)) {
            nextCell = 'map edge'
            break
          }
          nextCell = enty.cell + grid.height
          break
        case 'west':
          if( enty.cell % grid.width == 0) {
            nextCell = 'map edge'
            break
          }
          nextCell = enty.cell - 1
          break
      }
      return nextCell
    }

    var intendedPosition = nextCell(grid, enty, direction)
    if(intendedPosition == 'map edge') return enty;

    //Prevent movement (but update facing) if the object we are facing is impassable:
    enty.facing = this.examine(grid, intendedPosition)
    if(enty.facing && enty.facing.passable === false) return enty //< (unchanged)

    //Otherwise modify the enty's cell to simulate the movement:
    enty.cell = intendedPosition

    //Then update this enty's facing property again:
    enty.facing = this.examine( grid, nextCell(grid, enty, direction) )
    return enty
  }

  //Assign a unique id based on group:
  gg.indexIt = function(enty) {
    //Initialize a groups variable for the gg object:
    if(!this.groups) this.groups = {}
    //Find if the group has been established:
    if(!this.groups[enty.group]) {
      this.groups[enty.group] = {
        counter : -1
      }
    }
    enty.groupid = this.groups[enty.group].counter + 1
    //Increment the counter:
    this.groups[enty.group].counter++;
    //Then make the id a valid DOM selector:
    enty._id = 'e-' + enty.group + '[groupid="' + enty.groupid + '"]'
    return enty;
  }

  gg.examine = function(grid, cell) {
    var enty = _.find(grid.enties, function(enty) { return enty.cell == cell })
    if(_.isUndefined(enty)) enty = null
    return enty
  }

  gg.createGrid = function(width, height, type) {
    var grid = {
      _id : 'grid_0',
      width: width,
      height: height,
      enties: []
    }
    var rotMap
    //Accommodate for additional params:
    if(type == 'Cellular') {
      rotMap = new ROT.Map[type](width, height)
      //This map type has a special randomize function:
      rotMap.randomize(0.5)
    }
    else if(type == 'Digger') {
      rotMap = new ROT.Map[type](width, height, { dugPercentage : 0.6 })
    }
    else if(type == 'Uniform') {
      rotMap = new ROT.Map[type](width, height, { roomDugPercentage: 0.9 })
    }
    else {
      rotMap = new ROT.Map[type](width, height)
    }

    var cellCount = 0;
    rotMap.create(function(x, y, value) {
      console.log([x, y, value].join(', '))
      //For each value generated by rotMap, spit out a block:
      var blockenty = {
        group: 'thing',
        cell: cellCount,
        css : ['block'],
        passable : false
      }
      if(value) grid.enties.push(blockenty)
      cellCount++;
    })
    //Do an inventory of enties in the grid:
    grid.enties.forEach(function(enty) {
      enty = gg.indexIt(enty)
    })
    return grid;
  }

  //Returns an enty if the supplied enty is sharing the same cell as the supplied group:
  gg.isTouching = function (grid, enty, entyOrGroup) {
    var targetenty;
    if(!_.isObject(entyOrGroup)) {
      //Get any other enties in the same cell:
      var cellContents = _.filter(grid.enties, function(theEnty) {
        return theEnty.cell == enty.cell && theEnty.group == entyOrGroup
      })
      //Return said enty in the same cell otherwise, return false.
      if(cellContents.length > 0) return cellContents[0]
      return false
    } else if(_.isObject(entyOrGroup)){
      //If we supply an object then we are looking for a more specific match:
      var matchingenty = _.filter(grid.enties, function(theEnty) {
        return theEnty.cell == enty.cell && theEnty == entyOrGroup
      })
      if(_.isEmpty(matchingEnty)) return false
      return matchingEnty[0]
    }
  }

  gg.insertEnty = function(grid, cell, group, css) {
    //Params: obj, int, str, arr
    var enty = {
      group: group,
      cell: cell,
    }
    if(css) enty.css = css
    enty = this.indexIt(enty)
    grid.enties.push(enty)
    return grid
  }

  // Node.js specific:
  if (typeof module !== 'undefined' && module.exports) {
      module.exports = gg
  }
  // Otherwise, it's included directly via <script> tag (browser)
  else {
      root.gg = gg
  }

}());
